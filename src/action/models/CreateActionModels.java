package action.models;

import burlap.behavior.singleagent.Episode;
import burlap.mdp.core.action.Action;
import burlap.mdp.core.state.State;
import utilities.MurmurHash;
import weka.classifiers.trees.J48;
import weka.core.Attribute;
import weka.core.DenseInstance;
import weka.core.Instance;
import weka.core.Instances;
import weka.filters.Filter;
import weka.filters.unsupervised.attribute.AddValues;
import weka.filters.unsupervised.attribute.NumericToNominal;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class CreateActionModels {

	/**
	 * holds  the trained action tree stored first by action name then state variable
	 */
	private static Map<String, Map<String, VariableTree>> trees;


	/**
	 * uses weka j48 trees for each action found in the trajectories
	 * the reature vectur is the current state variables and the class
	 * is the next state's variable value
	 * @param trajectories set of trajectories which are generated by a
	 *                     learning agent in a small version of the target domain
	 * @return all trees which have been read into a custom\ tre class
	 */
	public static Map<String, Map<String, VariableTree>> createModels(List<Episode> trajectories){
		trees = new HashMap<String, Map<String, VariableTree>>();

		//collect all actions which was seen is the trajectories
		List<String> actions = new ArrayList<String>();
		for(Episode e : trajectories){
			for(Action a : e.actionSequence){
				if(!actions.contains(a.toString()))
					actions.add(a.toString());
			}
		}

		//iterate over the actions to make decision trees
		for(String action : actions){
			List<State> priorStates = new ArrayList<State>();
			List<State> postStates = new ArrayList<State>();
			List<Double> rewards = new ArrayList<Double>();

			//ewxtract the transitions which use the current action
			for(Episode trajectory : trajectories){
				for(int i = 0; i < trajectory.actionSequence.size(); i++){
					if(trajectory.actionSequence.get(i).toString().equals(action)){
						priorStates.add(trajectory.stateSequence.get(i));
						postStates.add(trajectory.stateSequence.get(i + 1));
						rewards.add(trajectory.rewardSequence.get(i));
					}
				}
			}

			//create a j48 to predict each state variable value in the next state given
			// the current state variables as a feature vector
			List<Object>  variables = trajectories.get(0).stateSequence.get(0).variableKeys();
			for(Object var : variables){
				//set up the attributes for the current tree
				ArrayList<Attribute> attributes = new ArrayList<Attribute>();
				attributes.add(new Attribute(var.toString() + "_prime"));
				
				for(Object variable : variables){
					
					attributes.add(new Attribute(variable.toString()));
				}

				//create an empty dataset where the first attribute is the class variable
				Instances dataset = new Instances(action + "_" + var.toString(), attributes, priorStates.size());
				dataset.setClassIndex(0);
				
				//create the training set
				for(int i = 0; i < priorStates.size(); i++){
					Instance dataPoint = new DenseInstance(variables.size() + 1);
					dataPoint.setDataset(dataset);

					//add the next state's variable as the label
					//if the variable is a string, it is included as the hashed value
					//using a universal hash function
					Object label = postStates.get(i).get(var);
					if(label instanceof Number){
						dataPoint.setValue(0, ((Number) label).doubleValue());
					}else{
						dataPoint.setValue(0, MurmurHash.hash32(label.toString()));
					}

					//add the current's state values to the feature vector
					State prior = priorStates.get(i);
					addSStateVars(dataPoint, prior);
					dataset.add(dataPoint);
				}

				//train the j48 tree, write it to a file,
				// and parse the tree into the variableTree class
				J48 tree = buildTree(dataset);
				writeTreeToFile(action, var.toString(), tree);
				addTree(action, var.toString(), tree);
			}
			
			//create tree for reward with claas as reward
			ArrayList<Attribute> attributes = new ArrayList<Attribute>();
			attributes.add(new Attribute("reward"));
			for(Object var : variables){
				attributes.add(new Attribute(var.toString()));
			}
			Instances dataset = new Instances(action + "_Reward", attributes, priorStates.size());
			dataset.setClassIndex(0);
			
			for(int i = 0; i < priorStates.size(); i++){
				Instance dataPoint = new DenseInstance(variables.size() + 1);
				dataPoint.setDataset(dataset);
				
				double label = rewards.get(i);
				dataPoint.setValue(0, label);
				
				State prior = priorStates.get(i);
				addSStateVars(dataPoint, prior);
				dataset.add(dataPoint);
			}
			J48 tree = buildTree(dataset);
			writeTreeToFile(action, "R", tree);
			addTree(action,"R", tree);
		}

		return trees;
	}

	/**
	 * read in the variable trees from a given folder and return the set of trees
	 * @param folderPath path to the files of trees
	 * @return tthe set of decision trees foound in the given tree
	 */
	public static Map<String, Map<String, VariableTree>> readTreeFiles(String folderPath){
		Map<String, Map<String, VariableTree>> parsedTrees = new HashMap<String, Map<String, VariableTree>>();
		File folder = new File(folderPath);
		File[] treeFiles = folder.listFiles();

		for(File tree : treeFiles){
			if(tree.isFile()){
				//parse the file name to get action and variable
				String name = tree.getName();
				String action = name.substring(0, name.indexOf("_"));
				String variable = name.substring(name.indexOf("_") + 1, name.indexOf("."));
				variable = variable.replace("_", ":");

				//read in the tree and put it into the set
				VariableTree parsedTree = new VariableTree(tree);
				Map<String, VariableTree> actionTrees = parsedTrees.get(action);
				if(actionTrees == null){
					actionTrees = new HashMap<String, VariableTree>();
					parsedTrees.put(action, actionTrees);
				}

				actionTrees.put(variable, parsedTree);
			}
		}
		return parsedTrees;
	}

	/**
	 * add all state variable values to the given data point
	 * @param dataPoint the data point to add to
	 * @param prior the current state
	 */
	private static void addSStateVars(Instance dataPoint, State prior) {
		int counter = 1;

		//numeric values are put in as numbers and string variables
		//are recorded as there univeral hash value
		for(Object varKey : prior.variableKeys()){
			Object value = prior.get(varKey);
			if(value instanceof Number){
				dataPoint.setValue(counter++, ((Number) value).doubleValue());
			}else{
				dataPoint.setValue(counter++, MurmurHash.hash32(value.toString()));
			}
		}
	}

	/**
	 * build a weka j48 tree using the given data to train
	 * @param dataset training set
	 * @return the trained J48 tree
	 */
	private static J48 buildTree(Instances dataset) {
		//apply filters
		try{
			//changed all attribute to nominal values
			//meaning eacch attribute has a finite number of values
			//this forces the tree to only use equality as
			NumericToNominal numericToNominal = new NumericToNominal();
			numericToNominal.setInputFormat(dataset);
			dataset = Filter.useFilter(dataset, numericToNominal);

			//j48 throw a error if the class label only has one variable
			//this filter adds a dummy option to the class attributte
			AddValues addval = new AddValues();
			String[] argVals = {"-C", "first", "-L", "_"};
			addval.setOptions(argVals);
			addval.setInputFormat(dataset);
			dataset = Filter.useFilter(dataset, addval);
		}catch(Exception ex){
			ex.printStackTrace();
		}

		//train tree
		J48 tree = new J48();
		try{
			String[] options = { "-M", "1", "-U"};
			tree.setOptions(options);
			tree.buildClassifier(dataset);
		}catch(Exception ex){
			ex.printStackTrace();
		}
		return tree;
	}

	/**
	 * writes a tree to the tree folder
	 * @param action the action use for the tree
	 * @param variable the variable used for the tree
	 * @param tree the trained j48 tree
	 */
	private static void writeTreeToFile(String action, String variable, J48 tree){
		String fname = "trees/" + action + "_" + variable.replace(":","_") + ".txt";
		try {
			System.out.println("Tree created for " + action + " and " + variable);
			String out = getCleanTreeString(tree);

			BufferedWriter write = new BufferedWriter(new FileWriter(fname));
			write.write(out);
			write.flush();
			write.close();

		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * remove the unnecessary text from a j48 tostring
	 * @param tree the tree
	 * @return a clean string representing the tree's nodes
	 */
	private static String getCleanTreeString(J48 tree) {
		String out = tree.toString();

		//remove first few lines which are blank ot have separators
		for (int i = 0; i < 2; i++) {
            out = out.substring(out.indexOf("\n") + 1);
        }

        //remove tree count from end of lines
		out = out.trim();
		out = out.replaceAll(" \\(.*\\)", "");

		int end = out.indexOf("Number of Leaves");
		if(end >= 0)
            out = out.substring(0, end );
		return out;
	}

	/**
	 * save a tree to the collection of trees
	 * @param action action used for the tree
	 * @param var the name of the label
	 * @param tree the trained tree
	 */
	private static void addTree(String action, String var, J48 tree){
		String treeStr = getCleanTreeString(tree);
		VariableTree parsedTree = new VariableTree(treeStr);

		Map<String, VariableTree> actionTrees = trees.get(action);
		if(actionTrees == null){
			actionTrees = new HashMap<String, VariableTree>();
			trees.put(action, actionTrees);
		}

		actionTrees.put(var, parsedTree);
	}
}
